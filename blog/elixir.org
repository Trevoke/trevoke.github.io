#+TITLE:       Why Elixir is the next Great Tech
#+AUTHOR:      Aldric Giacomoni
#+EMAIL:       trevoke@gmail.com
#+DATE:        2016-03-31 Thu
#+URI:         /blog/%y/%m/%d/why-elixir-is-the-next-great-tech
#+KEYWORDS:    elixir
#+TAGS:        elixir
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: A list of reasons why Elixir is great

* Elixir, because:

I think of it has an idea whose time has come - or rather, a great gathering of ideas.

- Erlang has solved the problem of distributed computing (and therefore, of concurrency) decades ago, and now concurrency is a very desirable tool, as the amount of data we crunch regularly has increased exponentially.
- TDD has brought a more functional approach to a lot of people's code, and that is the paradigm Elixir espouses.
- Elixir takes all of the syntax niceness from Ruby, so it's pretty and easy to read.
- Elixir makes OTP incredibly convenient to use, which means creating a new process, keeping track of it, and communicating with it, and each maybe one line of code, instead of the the ridiculous amount of code you'd need in other languages.
- Elixir's Phoenix Framework makes both stateless (traditional request/response) and stateful (anything from long-polling to websockets) connections very simple to use, by providing very powerful abstractions based on OTP. The code remains readable.
- Elixir's Phoenix Framework takes from all the lessons of Rails and Javascript of the past decade and has created a testable, maintainable, extendable web MVC framework that is in actuality just another OTP application
- As we depend more and more on external services (API, whether internal or external), fault tolerance becomes top-of-mind when building robust systems. This is another problem Erlang has solved years ago, through supervisors and choosing how to handle crashes.
- Elixir/OTP allows for crazy uptime by letting you write code in such a way that you can actually do hot reloading.
- Elixir implements real macros, one of the very few non-lisp languages to do so, and does so fairly cleanly. This allows you to, should you need it, create your own domain language in your code.

As we move more towards microservices, and given that a microservice is the unit of thought in Elixir (an OTP app is just a service that can receive messages, send messages, and hold state), it will become a de-facto choice, because it is a superior abstraction to the existing choices.

As I mentioned above, it lets you create websocket connections very easily, maintaining a single state via the socket, which is also a rather tempting idea for folks using the Flux architecture in the front-end.
